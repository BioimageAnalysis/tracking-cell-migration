classdef ECMCellTracker
    %ECMCELLTRACKER  Track cells for epithelial cell migration project
    %
    %  T = ECMCELLTRACKER creates a new object that can be used to track
    %  epithelial cell nuclei for the cell migration project. The images
    %  are expected to be generated by the Opera Phenix high-throughput
    %  imager.
    %
    %  Currently, the ECMCELLTRACKER object will process only specified
    %  subsets of images. These sub-images are defined by the row and
    %  column of the well and the field of view. See below for an example.
    %  The easiest way to obtain appropriate fields of view is to open the
    %  dataset in the Harmony viewer to ensure appropriate cell density.
    %
     % For each location processed, the code outputs a number of files:
     %   * An AVI-file showing the outline and ID of detected nuclei
     %   * A MAT-file containing information about the tracked nuclei
     %   * A text file of the parameters used to process the movie
     % 
     % The following variables should be present in the MAT-file:
     %   * 'tracks' and 'trackStruct' both containing the same information
     %     about tracked cells (see
     %     https://github.com/Biofrontiers-ALMC/cell-tracking-toolbox/wiki/overview-trackarray)
     %   * 'isTrackValid' - a logical array showing if the indexed track
     %     has a length of at least 90% of the movie.  
    %
    %  Also note that due to the high-throuhghput nature of the Opera
    %  Phenix imager, occasional frames are skipped by the hardware. The
    %  tracker tries to account for this, but will stop processing if more
    %  than 10 frames are skipped in a row as the tracking will likely no
    %  longer work at that point.
    %
    %  To help speed up processing, ECMCELLTRACKER implements parallel
    %  processing using the MATLAB toolbox. To enable this, set
    %  ParallelProcess to true. Total number of workers can be set using
    %  the ParallelRequestedWorkers property or in your MATLAB settings.
    %
    %  Example:
    %
    %  %Create a new object
    %  T = ECMCELLTRACKER;
    %
    %  %Change settings
    %  T.NucleiQuality = 10;
    %
    %  %Process wells C2 (field 7) and E9 (field 8)
    %  process(T, DIR, [3, 2, 7; 5, 9, 8])
    %
    %  See also: ECMCellTracker/process

    properties

        MaxLinkingDistance = 15;  %Distance in pixels that linking is allowed
        NucleiQuality = 20;  %The higher the number, the less nuclei detected
        ROI = [];  %Set to process only part of the image. Leave blank [] to process whole image.

        FrameRange = 1:110;

        ParallelProcess = false;  %Set to true to enable parallel processing
        ParallelRequestedWorkers = 4;

    end

    methods

        function process(obj, dataDir, outputDir, varargin)
            %PROCESS  Identify and track nuclei in Opera Phenix images
            %
            %  PROCESS(OBJ, DATADIR, OUTPUTDIR) will process all wells and
            %  fields of the dataset in DATADIR. The resulting data will be
            %  saved to OUTPUTDIR. If either directory is not specified, a
            %  dialog box will pop up to allow the user to select one.
            %
            %  PROCESS(OBJ, ..., COORDS) will process only the wells and
            %  fields specified. COORDS must be an N-by-3 matrix where each
            %  row specifies the [ROW, COL, FIELD] to process
            %
            %  Note that this function handles the files and any parallel
            %  processing. Actual processing code is in the function
            %  processFile.
            %
            %  See also: ECMCellTracker/processFile

            %Parse inputs
            if ~exist('dataDir', 'var')
                dataDir = uigetdir('', 'Select data directory');
            end

            if ~exist('outputDir', 'var')
                outputDir = uigetdir('', 'Select output directory');
            else
                if ~exist(outputDir, 'dir')
                    mkdir(outputDir);
                end
            end

            if isempty(varargin)

                %TODO: Get all wells and cols and fields from directory
            else

                locations = varargin{1};

            end

            numLocs = size(locations, 1);

            if obj.ParallelProcess && numLocs > 1
                M = obj.ParallelRequestedWorkers;
            else
                M = 0;
            end

            %Compile options
            opts.ROI = obj.ROI;
            opts.NucleiQuality = obj.NucleiQuality;
            opts.FrameRange = obj.FrameRange;
            opts.MaxLinkingDistance = obj.MaxLinkingDistance;

            %Process files
            %parfor (iFile = 1:numLocs, M)
            for iFile = 1:numLocs

                ECMCellTracker.processFile(dataDir, outputDir, locations(iFile, :), opts)

            end
        end

    end

    methods (Static)

        function processFile(dataDir, outputDir, loc, opts)
            %PROCESSFILE  Process a file
            %
            %  PROCESSFILE(DIR, OUPUT, LOC, OPTS) will process the image at
            %  the location provided. This method is intended to be called
            %  by the process() method of the main object. Implementation
            %  as a static function is to follow MATLAB best practices.
            %
            %  See also: ECMCellTracker/process

            row = loc(1);
            col = loc(2);
            field = loc(3);

            %Generate output filename
            [baseDir, ~] = fileparts(dataDir);
            [~, baseDir] = fileparts(baseDir);
            baseDir = regexprep(baseDir, '[+\- ]', '_');

            outputFN = [baseDir, '_r', sprintf('%02.0f', row), 'c', sprintf('%02.0f', col), 'f', sprintf('%02.0f', field)];

            fprintf('[%s] Starting processing file: %s\n', ...
                    datetime, outputFN)

            LAP = LAPLinker;
            LAP.LinkCostMetric = 'euclidean';
            LAP.TrackDivision = true;
            LAP.LinkScoreRange = [0 opts.MaxLinkingDistance];
            LAP.DivisionScoreRange = [0 20];

            vid = VideoWriter(fullfile(outputDir, [outputFN, '.avi']));
            vid.FrameRate = 5;
            open(vid)

            for iT = opts.FrameRange

                %Try reading the image. The Opera Phenix seems to
                %occasionally skip frames. If more than 10 frames are
                %skipped in a row, the function will print an error and
                %stop processing the current dataset.
                skippedFrames = 0;

                try

                    I = ECMCellTracker.readImage(dataDir, row, col, field, iT, 2);
                    skippedFrames = 0;

                catch

                    skippedFrames = skippedFrames + 1;

                    if skippedFrames > 10
                        fprintf('[%s] ERROR - Too many missing frames: %s\n', ...
                            datetime, outputFN)
                        break
                    end

                    continue

                end

                %Crop image if specified
                if ~isempty(opts.ROI)

                    I = I(opts.ROI(1):(opts.ROI(1) + opts.ROI(3)), ...
                        opts.ROI(2):(opts.ROI(2) + opts.ROI(4)));

                end

                %Identify the nuclei
                mask = ECMCellTracker.segmentCells(I, opts.NucleiQuality);

                %Measure nuclei position
                data = regionprops(mask, 'Centroid');

                LAP = assignToTrack(LAP, iT, data);

                %Generate output video
                Iout = double(I);
                Iout = (Iout - min(Iout, [], 'all'))/(max(Iout, [], 'all') - min(Iout, [], 'all'));

                Iout = showoverlay(imadjust(Iout), bwperim(mask));
                for iAT = LAP.activeTrackIDs
                    ct = getTrack(LAP, iAT);
                    Iout = insertText(Iout, ct.Centroid(end, :), int2str(iAT), ...
                        'TextColor', 'white', 'BoxOpacity', 0);
                end

                writeVideo(vid, Iout);

            end
            close(vid)

            tracks = LAP.tracks;
            trackStruct = tracks.Tracks;

            %Perform a quality check by looking for cells that are tracked
            %for at least 90% of the movie
            isTrackValid = false(1, tracks.NumTracks);
            for iTrack = 1:tracks.NumTracks

                if numel(tracks.Tracks.Frames) >= (0.9 * numel(opts.FrameRange))
                    isTrackValid(iTrack) = true;
                end
            end 
            nValidTracks = nnz(isTrackValid);

            save(fullfile(outputDir, [outputFN, '.mat']), ...
                'tracks', 'trackStruct', 'opts', ...
                'nValidTracks', 'isTrackValid');

            exportsettings(LAP, fullfile(outputDir, [outputFN, '_trackingParams.txt']));

            fprintf('[%s] Completed processing file: %s\n', ...
                    datetime, outputFN)
        end

        function mask = segmentCells(I, quality)
            %SEGMENTCELLS  Segment cells in image
            %
            %  MASK = SEGMENTCELLS(I, Q) identifies nuclei in the image I.
            %  The nuclei are expected to be small and round in shape. The
            %  algorithm works by using the difference of Gaussians filter
            %  to generate an initial mask. Watershedding and other
            %  morphological operators are then applied to remove unwanted
            %  objects from detection.
            %
            %  Q is the quality of nuclei detection. A higher Q value will
            %  result in less nuclei being detected, although the
            %  detections may be more accurate. 

            I = double(I);

            Idg1 = imgaussfilt(I, 4);
            Idg2 = imgaussfilt(I, 1);

            Idog = Idg2 - Idg1;

            mask = Idog > quality;

            dd = -bwdist(~mask);
            dd(~mask) = false;
            dd = imhmin(dd, 0.7);

            L = watershed(dd);

            mask(L == 0) = false;
            mask = imclearborder(mask);


        end

        function img = readImage(dataDir, varargin)
            %READIMAGE  Reads an image from Harmony
            %
            %  I = READIMAGE(FOLDER, ROW, COL) reads the (first) image at
            %  the specified well. Additional parameters can be passed on
            %  to specify the field of view, frame, channel, and z-plane to
            %  read. Note that the parameters must be passed in that order.
            %  FOLDER should be the path to the folder that exported from
            %  the Harmony software.
            
            ip = inputParser;
            addRequired(ip, 'row')
            addRequired(ip, 'col')
            addOptional(ip, 'field', 1)
            addOptional(ip, 'frame', 1)
            addOptional(ip, 'channel', 1)            
            addOptional(ip, 'plane', 1)
            parse(ip, varargin{:})

            filename = ...
                sprintf('r%02dc%02df%02dp%02d-ch%dsk%dfk1fl1.tiff', ...
                ip.Results.row, ...
                ip.Results.col, ...
                ip.Results.field, ...
                ip.Results.plane, ...
                ip.Results.channel, ...
                ip.Results.frame);

            %Harmony output filename:
            % r03c03f01p01-ch1sk1fk1fl1.tiff
            %
            % Where
            % r (01-08) = row
            % c (01-12) = column
            % f (01-09) = field
            % p (01-21) = plane
            % ch (1-4) = channel

            if ~exist(fullfile(dataDir, filename), 'file')
                error('ECMCellTracker:readImage:FileNotFound', 'Could not find file %s.', ...
                    filename)
            end

            img = imread(fullfile(dataDir, filename));

        end

        function varargout = showoverlay(img, mask, varargin)
            %SHOWOVERLAY  Overlays a mask on to a base image
            %
            %  SHOWOVERLAY(I, M) will overlay mask M over the image I, displaying it in
            %  a figure window.
            %
            %  C = SHOWOVERLAY(I, M) will return the composited image as a matrix
            %  C. This allows multiple masks to be composited over the same image. C
            %  should be of the same class as the input image I. However, if the input
            %  image I is a double, the output image C will be normalized to between 0
            %  and 1.
            %
            %  Optional parameters can be supplied to the function to modify both the
            %  color and the transparency of the masks:
            %
            %     'Color' - 1x3 vector specifying the color of the overlay in
            %               normalized RGB coordinates (e.g. [0 0 1] = blue)
            %
            %     'Transparency' - Value between 0 - 100 specifying the alpha level of
            %                      the overlay
            %
            %  Examples:
            %
            %    %Load a test image
            %    testImg = imread('cameraman.tif');
            %
            %    %Generate a masked region
            %    maskIn = false(size(testImg));
            %    maskIn(50:70,50:200) = true;
            %
            %    %Store the image to a new variable
            %    imgOut = SHOWOVERLAY(testImg, maskIn);
            %
            %    %Generate a second mask
            %    maskIn2 = false(size(testImg));
            %    maskIn2(100:180, 50:100) = true;
            %
            %    %Composite and display the second mask onto the same image as a
            %    %magenta layer with 50% transparency
            %    SHOWOVERLAY(imgOut, maskIn2, 'Color', [1 0 1], 'Transparency', 50);

            ip = inputParser;
            ip.addParameter('Color',[0 1 0]);
            ip.addParameter('Opacity',100);
            ip.addParameter('Normalize', true);
            ip.parse(varargin{:});

            alpha = ip.Results.Opacity / 100;

            %Get the original image class
            imageClass = class(img);
            imageIsInteger = isinteger(img);

            % %Process the input image
            if ip.Results.Normalize
                img = double(img);
                img = img ./ max(img(:));
            end

            if size(img,3) == 1
                %Convert into an RGB image
                img = repmat(img, 1, 1, 3);
            elseif size(img,3) == 3
                %Do nothing
            else
                error('showoverlay:InvalidInputImage',...
                    'Expected input to be either a grayscale or RGB image.');
            end

            %Process the mask
            mask = double(mask);
            mask = mask ./ max(mask(:));

            if size(mask,3) == 1
                %Convert mask into an RGB image
                %mask = repmat(mask, 1, 1, 3);

                replacePx = mask ~= 0;

                for iC = 1:3
                    %mask(:,:,iC) = mask(:,:,iC) .* ip.Results.Color(iC);

                    currC = img(:,:,iC);
                    currC(replacePx) = (currC(replacePx) .* (1 - alpha)) + (mask(replacePx) .* alpha .* ip.Results.Color(iC));

                    img(:,:,iC) = currC;
                end


            elseif size(mask,3) == 3

                %Make the composite image
                replacePx = mask ~= 0;

                img(replacePx) = img(replacePx) .* (1 - alpha) + mask(replacePx) .* alpha;

            else
                error('showoverlay:InvalidMask',...
                    'Expected mask to be either a logical or RGB image.');
            end


            %Recast the image into the original image class
            if imageIsInteger
                multFactor = double(intmax(imageClass));
                img = img .* multFactor;
                img = cast(img, imageClass);
            else
                %multFactor = 1;
            end



            %Produce the desired outputs
            if nargout == 0
                imshow(img,[])
            else
                varargout = {img};
            end

        end

    end



end